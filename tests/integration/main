package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/signal"
	"strconv"
	"sync"
	"syscall"
	"time"

	cloudevents "github.com/cloudevents/sdk-go/pkg/cloudevents"
	"github.com/nats-io/nats.go"
	"github.com/nats-io/nats.go/jetstream"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

const (
	natsURL          = nats.DefaultURL
	subjectTemplate  = "randomtalk.notifications.chat.users"
	matchmakingTopic = "randomtalk.matchmaking.matches.>"
	numberOfUsers    = 10000
	expectedMatches  = 5000
	shutdownTimeout  = 5 * time.Minute
)

type NATSClient struct {
	nc *nats.Conn
	js jetstream.JetStream
}

func main() {
	// Setup logger
	log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})
	zerolog.SetGlobalLevel(zerolog.DebugLevel)

	ctx, shutdownCancel := context.WithCancel(context.Background())
	defer shutdownCancel()

	// Initialize NATS client
	natsClient, err := NewNATSClient(natsURL)
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to initialize NATS client")
	}
	defer natsClient.Close()

	// Publish messages
	go publishChatNotifications(ctx, natsClient)

	// Handle OS signals
	done := handleNATSShutdown(ctx, natsClient)

	// Start match event listener
	listenForMatches(ctx, natsClient, shutdownCancel)

	<-done
}

func NewNATSClient(url string) (*NATSClient, error) {
	nc, err := nats.Connect(url)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to NATS: %w", err)
	}

	js, err := jetstream.New(nc)
	if err != nil {
		nc.Close()
		return nil, fmt.Errorf("failed to create JetStream: %w", err)
	}

	return &NATSClient{nc: nc, js: js}, nil
}

func (n *NATSClient) Close() {
	_ = n.nc.Drain()
	n.nc.Close()
}

func publishChatNotifications(ctx context.Context, client *NATSClient) {
	var wg sync.WaitGroup
	wg.Add(numberOfUsers)

	for i := 1; i <= numberOfUsers; i++ {
		go func(userID int) {
			defer wg.Done()

			event := cloudevents.New()
			event.SetID(fmt.Sprintf("chat_session_started_%d", userID))
			event.SetType("chat_session_started")
			event.SetSource("https://randomtalk.com/chat/notifications")
			event.SetSubject(fmt.Sprintf("user.%d", userID))
			event.SetTime(time.Now())

			data := map[string]interface{}{
				"user_id":     strconv.Itoa(userID),
				"user_age":    20,
				"user_gender": "GENDER_MALE",
				"user_preferences": map[string]interface{}{
					"min_age":   20,
					"max_age":   30,
					"interests": []string{"music", "sports"},
				},
			}

			event.SetDataContentType(cloudevents.ApplicationJSON)
			if err := event.SetData(data); err != nil {
				log.Error().Err(err).Msg("Failed to set event data")
				return
			}

			body, err := json.Marshal(event)
			if err != nil {
				log.Error().Err(err).Msg("Failed to marshal event")
				return
			}

			subject := fmt.Sprintf("%s.%d.connected", subjectTemplate, userID)
			log.Info().Msgf("Publishing message to %s", subject)

			if _, err := client.js.Publish(ctx, subject, body,
				jetstream.WithMsgID(fmt.Sprintf("chat_session_started_%d", userID)),
			); err != nil {
				log.Error().Err(err).Msg("Failed to publish message")
			}
		}(i)
	}

	wg.Wait()
}

func listenForMatches(ctx context.Context, client *NATSClient, cancel context.CancelFunc) {
	consumer, err := client.js.OrderedConsumer(ctx, "randomtalk_matchmaking_match_events", jetstream.OrderedConsumerConfig{
		FilterSubjects:    []string{matchmakingTopic},
		InactiveThreshold: 1 * time.Minute,
	})
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to create ordered consumer")
	}

	matchesUniqueMap := sync.Map{}
	matchesFound := 0
	duplicatedMatches := 0

	jsctx, err := consumer.Consume(func(msg jetstream.Msg) {
		match, err := processMatchMessage(msg)
		if err != nil {
			log.Error().Err(err).Msg("Failed to process message")
		}

		if _, loaded := matchesUniqueMap.LoadOrStore(match.RequesterID, struct{}{}); loaded {
			duplicatedMatches++
			log.Warn().Msgf("Duplicated match found for user %s", match.RequesterID)
		}

		if _, loaded := matchesUniqueMap.LoadOrStore(match.CandidateID, struct{}{}); loaded {
			duplicatedMatches++
			log.Warn().Msgf("Duplicated match found for user %s", match.CandidateID)
		}

		matchesFound++
		log.Debug().Msgf("Matches found: %d", matchesFound)
	})
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to consume messages")
	}

	defer func() {
		jsctx.Drain()
	}()

	<-ctx.Done()
	log.Info().
		Int("duplicated_matches", duplicatedMatches).
		Int("matches_found", matchesFound).
		Msg("âœ… Matchmaking Integration Test Complete Successfully")
}

type payload struct {
	RequesterID string `json:"match_user_requester_id"`
	CandidateID string `json:"match_user_matched_id"`
}

func processMatchMessage(msg jetstream.Msg) (*payload, error) {
	var event cloudevents.Event
	if err := json.Unmarshal(msg.Data(), &event); err != nil {
		return nil, fmt.Errorf("failed to unmarshal CloudEvent: %w", err)
	}

	var payload *payload
	if err := event.DataAs(&payload); err != nil {
		return nil, fmt.Errorf("failed to parse event data: %w", err)
	}

	if err := msg.Ack(); err != nil {
		return nil, fmt.Errorf("failed to acknowledge message: %w", err)
	}

	log.Debug().Msgf("Match found between %s and %s", payload.RequesterID, payload.CandidateID)
	return payload, nil
}

func handleNATSShutdown(ctx context.Context, client *NATSClient) <-chan struct{} {
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	doneCh := make(chan struct{})

	go func() {
		defer close(doneCh)

		select {
		case <-ctx.Done():
		case <-sigChan:
		case <-time.After(shutdownTimeout):
			log.Warn().Msg("Timeout waiting for matches, shutting down")
		}

		client.Close()
		log.Info().Msg("Shutdown complete")
	}()

	return doneCh
}
